# Probabilistic road classification in historical maps using synthetic data and deep learning
Dominik J. Mühlematter, Sebastian Schweizer, Chenjing Jiao, Xue Xia, Magnus Heitzler, Lorenz Hurni - 2024

## Abstract
Historical maps are invaluable for analyzing long-term changes in transportation and spatial development, offering a rich source of data for evolutionary studies. However, digitizing and classifying road networks from these maps is often prohibitively expensive and time-consuming, limiting their widespread use. Recent advancements in deep learning have made automatic road extraction from historical maps feasible, yet these methods typically require large amounts of expensive labeled training data. To tackle this challenge, we present a new framework that combines deep learning with statistical analysis, GIS, and image processing techniques. This framework enables the extraction and classification of roads from historical maps using only road geometries without needing road class labels for training. The process begins with training a binary segmentation model to extract road geometries, followed by morphological operations, skeletonization, vectorization, and filtering algorithms. Synthetic training data is then generated by a painting function that artificially re-paints road segments using predefined symbology for road classes. Based on this synthetic data, a calibrated deep ensemble is trained to produce pixel-wise road class probabilities. The final predictions are analyzed by calculating zonal statistics for entire roads and individual road segments. A Mann-Whitney-U-Test is subsequently conducted to assign road categories to each segment. Our method achieved a completeness and a correctness score of around 90\% for road class 2, the most prevalent class in the two Siegfried Map sheets from Switzerland used for testing. This research offers a powerful tool for urban planning and transportation decision-making by efficiently extracting and classifying roads from historical maps.

## Overview
<p align="center">
    <figure>
        <img src="Plots/Figures_Readme/Schema.png" alt="Method overview" height="300">
        <figcaption>Geodata © Swisstopo (https://www.swisstopo.admin.ch/en)
  </figcaption>
    </figure>
</p>

First, a pre-trained binary segmentation model is fine-tuned to extract road geometries from historical maps. This is followed by morphological operations, filtering, and vectorization. Next, symbol painting is used to generate synthetic training data with road class labels by randomly overpainting roads with specific class symbology. Subsequently, a deep ensemble predicts pixel-wise class probabilities, which are combined with the previously extracted road geometries. Zonal statistics within a buffer around each road are calculated by averaging the predicted class probabilities. To leverage our prior knowledge that road classes are unlikely to change within a road segment, we apply the Mann-Whitney U Test to classify road segments. This test identifies segments with predicted classes that significantly differ from the rest of the road by examining if the predicted probabilities are significantly different. The approach results in a vectorized road dataset evaluated on the Swiss Siegfried Map.

## Getting Started
Step 1: Clone or download this repository and set it as the working directory, create a virtual environment and install the dependencies.

```bash
cd road-seg-hist-maps/ 
```

Step 2: Create a virtual environment and install the dependencies specified in the .yml files (can be found in the folder of each task).

 
## 1. 01_CNN
This section of the code is intended to train a binary road segmentation model. Once the model is trained, it generates and saves predictions for the validation and test sets to the disk.
#### Data pre-processing
1. Create a folder with the name "dataset" in the repository.
2. Create a subfolder with the names "segmentation" and "segmentation_pretraining".
3. Create subfolders with the names "train", "validate", and "test" within "segmentation".
4. Create subfolders with the names "train", "validate", and "data" within "segmentation_pretraining".
5. Create subfolders within each of the subfolders in "segmenation" with the names "labels", "mask", "road_geoms", and "siegfried_sheets".
6. Create subfolders within each of the subfolders in "segmentation_pretraining" with the names "labels", "road_geoms", and "swissmap_sheets".
7. Copy the corresponding Swiss Map sheets as GeoTiff-files into the folders "segmentation_pretraining\train\swissmap_sheets" and "segmentation_pretraining\validate\swissmap_sheets". The naming should match the pattern '{sheet_number}_map.tif'.
8. Copy the corresponding  Siegfried Map sheets as GeoTiff-files into the folders "segmentation\train\siegfried_sheets", "segmentation\validate\siegfried_sheets" and "segmentation\test\siegfried_sheets". The naming should match the pattern '{sheet_number}_map.tif'.
9. Copy the corresponding road geometries as ESRI Shapefile into the folder folders "segmentation_pretraining\train\road_geoms" and "segmentation_pretraining\validate\road_geoms". The naming should match the pattern '{sheet_number}_road_geoms.shp'.
10. Copy the corresponding road geometries as ESRI Shapefile into the folder folders "segmentation\train\road_geoms", "segmentation\validate\road_geoms", and "segmentation\test\road_geoms". The naming should match the pattern '{sheet_number}_road_geoms.shp'.
11. In the case that there is not full coverage of labeled road geometries for a full Siegfried Map sheet, also copy for the corresponding Siegfried Map sheet a binary mask as GeoTiff-files into the folders "segmentation\train\masks", "segmentation\validate\masks" and "segmentation\test\masks". The naming should match the pattern '{sheet_number}_mask.tif'. Please be aware that the mask GeoTIff-file must have the same coordinate reference system, the same extent and the same pixel resolution as the Siegfried Map sheet does.

#### Train a binary road segmentation model
1. Modify the variable "BUFFERSIZE" in file 01_CNN/data/data_utils.py 
```python
BUFFERSIZE = 10
```
2. Modify the constant variable "path" in file 01_CNN/main.py by assigning the path to the desired model settings (JSON's within model_settings subfolders)
```python
path = "c:\\Road_segmentation\\road-seg-hist-maps\\01_CNN\\model_settings\\Binary_road_segmentation\\Segmentation_Final\\Siegfried_settings_Final.josn"
```
3. If a pre-trained model is fine-tuned, check if model weights are available within the folder 01_CNN/storage/01_CNN/models with the same name as the field "pretrained_model_name" in the chosen settings JSON file.
4. Set field value of field "save_output" to true to save predictions within the folder 01_CNN/storage/01_CNN/results
5. Run main.py file

#### Evaluate a trained model on validation or test set
1. Modify the variable "BUFFERSIZE" in file 01_CNN/data/data_utils.py 
```python
BUFFERSIZE = 10
```
2. Modify the constant variable "path" in file 01_CNN/main.py by assigning  the path to the desired model settings (JSONS's within model_settings subfolders)
```python
path = "c:\\Road_segmentation\\road-seg-hist-maps\\01_CNN\\model_settings\\Binary_road_segmentation\\Segmentation_Final\\Siegfried_settings_Final_mc_val.json"
```
3. Check if model weights are available within the folder 01_CNN/storage/01_CNN/models with the same name as the field "pretrained_model_name" in the chosen settings JSON file. 
4. Set field value of field "save_output" to true to save predictions within the folder 01_CNN/storage/01_CNN/results
5. Run main.py file

#### Model settings

| Model             | Train settings  | Val settings   | Test settings     |  Test accuracy | Test IoU |
|----------------------|------------------------|-----------------------|-------------------|------------------------------------------|------------------------------|
| <sup>Small U-Net<sup> | <sup>Siegfried_settings_baseline0_modelstudy.json<sup> | <sup>Siegfried_settings_baseline0_modelstudy_val.json<sup> | <sup>Siegfried_settings_baseline0_modelstudy_test.json<sup> | <sup>97.69% <sup> |<sup>76.31%<sup>|
| <sup>Res-U-Net no pre-training<sup> | <sup>Siegfried_settings_full_training1_modelstudy.json<sup> | <sup>Siegfried_settings_full_training1_modelstudy_val.json<sup> | <sup>Siegfried_settings_full_training1_modelstudy_test.json<sup>| <sup>98.05%<sup> |<sup>79.30%<sup>|
| <sup>Res-U-Net ImageNet<sup> | <sup>Siegfried_settings_not_pretrained_finetuning1_modelstudy.json<sup> | <sup>Siegfried_settings_not_pretrained_finetuning1_modelstudy_val.json<sup> | <sup>Siegfried_settings_not_pretrained_finetuning1_modelstudy_test.json<sup> |<sup>97.76% <sup> |<sup>77.06%<sup>|
| <sup>Res-U-Net ImageNet + Swiss Map<sup> | <sup>Siegfried_settings_Final.json<sup> | <sup>Siegfried_settings_Final_val.json<sup> | <sup>Siegfried_settings_Final_test.json<sup> | <sup>98.25%<sup> |<sup>81.27%<sup>|
| <sup>**MC Res-U-Net ImageNet + Swiss Map**<sup> | <sup>Siegfried_settings_Final.json<sup> | <sup>Siegfried_settings_Final_mc_val.json<sup> | <sup>Siegfried_settings_Final_mc_test.json<sup> | <sup>98.28%<sup> |<sup>81.43%<sup>|

Additional experiment settings can be located in the respective subdirectories:

1. Model_selection_study:
   - Settings for training with different learning rates for the models listed in the table above for hyperparameter tuning.

2. Data_augmentation_study:
   - Settings for evaluating various data augmentation strategies with the Small-U-Net architecture.

3. Dropout_p_study:
   - Settings for experiments to tune the dropout probability (p) during inference for the MC Res-U-Net Model.

4. Ensemble_size_study:
   - Experiments to assess the effect of different numbers of ensemble members on the MC Res-U-Net Model.

5. Segmentation_Final:
   - Settings for training the final Res-U-Net model, as well as settings for evaluating the MC Res-U-Net. Additionally, settings for pretraining and evaluating the model on Swiss Map.

   

## 2. 02_Postprocessing_Segmentation

#### Data
- Create a subfolder "input" in the folder "02_postprocessing_segmentation"
- Insert the Siegfired map sheets in the input folder with the naming like {SIGFRIED_FILENAME_PREFIX}_{sheet_number}.tif
- Insert the tiles with the prediction of the Segmentation model in the input folder with the naming like {sheet_number}_{index}.tif

#### Setting
Set settings in the header of the file script_postprocessing_segmentation.py
- Set the sheet numbers of the Siegfried map sheets which should be processed
```python
SHEET_NUMBERS = ['017', '199', '385']
```
- Set the prefix of the Siegfried map sheet files e.g. 'rgb_TA_' if the file is named 'rgb_TA_017.tif'
```python
SIGFRIED_FILENAME_PREFIX = 'rgb_TA_'
```
- Set the area thershold for the connected components filtering
```python
CC_AREA_THRESHOLD = 100
```
- Set the threshold for the Douglas-Peucker algorithm
```python
DOUGLAS_PEUCKER_THRESHOLD = 1.9
```

#### Run script
- Run file script_postprocessing_segmentation.py
- The output will be saved in the folder "02_postprocessing_segmentation/output" and will have an ESRI Shapefile per processed Siegfried sheet containing the road geometries. These files will be named like {sheet_number}_roads.shp.
- The intermediate results will be saved in the folder "02_postprocessing_segmentation/temp". For each Siegfried sheet there will be a GeoTiff with contains:
  - The used mask which is default everywhere true (name: {sheet_number}_mask.tif)
  - The stiched map from the segmentation predition tiles (name: {sheet_number}_segmentation.tif)
  - The output of the morphological operations (name: {sheet_number}_morphological_operations.tif)
  - The output of the skeletonization (name: {sheet_number}_skeleton.tif)

## 3. 01_CNN

#### Data
1. Create a subfolder with the name "classification" in the folder "datasets.
2. Create subfolders with the names "train", "validate", and "test" within "classification".
3. Create subfolders within each of the subfolders in "classification" with the names  "road_geoms", "temp", and "siegfried_sheets".
4. Create a subfolder within "train" and "validate" with the name "road_geoms_labled".
5. Create a subfolder within "train" with the name "masks".
6. Create a subfolder within "test" with the name "road_geoms_predicted".
8. Copy the corresponding Siegfried Map sheets as GeoTiff-files into the folders "classification\train\siegfried_sheets", "classification\validate\siegfried_sheets" and "classification\test\siegfried_sheets". The naming should match the pattern '{sheet_number}_map.tif'.
9. Copy the corresponding predicted road geometries as ESRI Shapefile from the folder "02_postprocessing_segmentation/output" into the folder folders "classification\validate\road_geoms_ground_truth" and "segmentation\test\road_geoms_predicted". The naming should match the pattern '{sheet_number}_road_geoms.shp'.
10. Copy the true road geometries containing the true road class label as an attribute called `road_cat` of type integer into the folder "segmentation\test\road_geoms_ground_truth". The naming should match the pattern '{sheet_number}_road_geoms.shp'.


#### Data pre-processing for classification (create synthetic data)
*Settings*

Set the constants in the header of the file script_preprocess_classfication_data.py
- Set the buffer size in pixels to draw the labels of the road classes
```python
BUFFERSIZE_LABELS = 10
```
- Set the buffer size in pixels for overpainting the Siegfried map sheets with the predicted road geometries.
```python
BUFFERSIZE_BACKGROUND_OVERPAINTING = 17
```
- Set the buffer size in pixels of the break point labels
```python
BREAKPOINT_BUFFER_RADIUS = 8
```

*Symbolization*

Define the hyperparameter of the symbolization (deterministic and stochastic) in the header of the file script_preprocess_classfication_data.py
```python
PAINTING_STD = {
    'offset': 0.2,  # meter
    'dash': 0.5,  # meter
    'thickness': 0.35  # pixel
}

SYMBOLIZATION = {
    5: {
        'offset': 8.25,  # meter
        'thickness_line_1': 3,  # pixel
        'thickness_line_2': 1.5  # pixel
    },
    4: {
        'offset': 5.6,  # meter
        'thickness': 1.5  # pixel
    },
    3: {
        'offset': 4.7,  # meter
        'gap_length': 7.5, #10,  # meter
        'dash_length': 11, #14,  # meter
        'thickness_line_dashed': 1.75,  # pixel
        'thickness_line_solid': 1.75  # pixel
    },
    2: {
        'thickness': 2, #1.75  # pixel
    },
    1: {
        'gap_length': 12.5,  # meter
        'dash_length': 17.5, #17,  # meter
        'thickness': 2, #1.75  # pixel
    }
}
```


*Run script*

This will create the synthetic data for the road classification task and save all relevant tiles in the dataset folder.

Run script_preprocess_classfication_data.py



#### Train ensemble for road classification
1. Modify the variable "BUFFERSIZE" in file 01_CNN/data/data_utils.py 
```python
BUFFERSIZE = 13
```
2. Modify the path on line 26 in file 01_CNN/train_ensemble.py by assigning  the absolute path to the desired model settings (folder with "Siegfried_settings_labelsmoothing" JSON's)
```python
settings_path = const.SETTINGS_DIR.joinpath("c:\\Road_segmentation\\road-seg-hist-maps\\01_CNN\\model_settings\\Road_classification\\Final_ensemble_label_smoothing\\Siegfried_settings_labelsmoothing_{}.json".format(i))
```
3. Specify the number of ensemble members by modifying the variable "N_members" in file 01_CNN/train_ensemble.py
```python
n_members = 30
```
4. If a pre-trained model is fine-tuned, check if model weights are available within the folder 01_CNN/storage/01_CNN/models with the same name as the field "pretrained_model_name" in the chosen settings JSON file. The trained models can be downloaded under the following link:
TODO: add HF link to model weights
5. Run train_ensemble.py file

#### Evaluate a trained model on validation or test set
1. Modify the variable "BUFFERSIZE" in file 01_CNN/data/data_utils.py 
```python
BUFFERSIZE = 13
```
2. Modify constant variable "path" in file 01_CNN/main.py by assigning  path to the desired model settings (JSON's within model_settings subfolders)
```python
path = "c:\\Road_segmentation\\road-seg-hist-maps\\01_CNN\\model_settings\\Road_classification\\Final_ensemble_label_smoothing\\Siegfried_settings_labelsmoothing_30_members_val.json"
```
3. Check if model weights for each ensemble member are available within the folder 01_CNN/storage/01_CNN/models with the same name as the field "pretrained_model_name" in the chosen settings JSON file. 
4. Set field value of field "save_output" to true to save predictions within the folder 01_CNN/storage/01_CNN/results in the ensemble model settings (e.g., Siegfried_settings_labelsmoothing_30_members_val.json)
5. Run main.py file

TODO: run script_preprocess_classfication_data.py

#### Model settings
The settings for training the ensemble members and evaluating the ensembles can be found in the folder 01_CNN//model_settings//Road_classification//Final_ensemble_label_smoothing. The final model used for the paper contained 30 members.

## 4. Option A: 03_Postprocessing_Classification_Breakpoint_Approach
#### Data
- Create a subfolder "input" in the "03_postprocess_classification_breakpoint_approach" folder.
- Insert the Siegfried map sheets in the input folder with the naming like {SIGFRIED_FILENAME_PREFIX}_{sheet_number}.tif
- Insert the GeoTiff with the hard mask in the input folder with the naming like {sheet_number}_hard_mask.tif
- Insert the predicted road geometries in the input folder with the naming like {sheet_number}_road_geoms.shp
- Insert the tiles with the predictions of the classification model in the input folder with the naming like {sheet_number}_{index}_class{road_cat}.tif
- Insert the tiles with the predictions of the breakpoint model in the input folder with the naming like {sheet_number}_{index}{BREAKPOINT_FILENAME_SUFFIX}.tif

#### Setting
Set settings in the header of the file script_postprocessing_classification_breakpoint_approach.py
- Set the sheet numbers of the Siegfried map sheets which should be processed
```python
SHEET_NUMBERS = ['017', '199', '385']
```
- Set the prefix of the Siegfried map sheet files e.g. 'rgb_TA_' if the file is named 'rgb_TA_017.tif'
```python
SIGFRIED_FILENAME_PREFIX = 'rgb_TA_'
```
- Set the suffix of the breakpoint files e.g. '_breakpoint' if the file is named '017_0_breakpoint.tif'
```python
BREAKPOINT_FILENAME_SUFFIX = '_breakpoint'
```
- Set the buffer radius in pixels to filter out predictions at known intersections
```python
INTERSECTION_POINT_BUFFER_RADIUS = 20 # pixels
```
- Set the buffer radius in meters to define the area of a breakpoint that must overlap with a road geometry to be considered
```python
BREAKPOINT_BUFFER_RADIUS = 4 # meters
```
- Set one or more buffer sizes in meters to calculate the zonal statistics
```python
BUFFERSIZES_METER = [6] # meters
```

#### Run script
- Run file script_postprocessing_classification_breakpoint_approach.py
- The output will be saved in the folder "03_postprocess_classification_breakpoint_approach/output" and will have an ESRI Shapefile per processed Siegfried sheet containing the road geometries. These files will be named like {sheet_number}_roads.shp.
- The intermediate results will be saved in the folder "03_postprocess_classification_breakpoint_approach/temp". For each Siegfried sheet there will be a GeoTiff or ESRI Shapefile which contains:
  - The vectorized breakpoint geometries (name: {sheet_number}_breakpoints.shp)
  - The road geometries with the inserted breakpoints (name: {sheet_number}_roads_with_breakpoints.shp)
  - The stiched maps for containing the predicted probavilities from the classification model (name: {sheet_number}_classification_class_{road_cat}.tif)

## 4. Option B: 03_Postprocessing_Classification_Testing_Approach
#### Data
- Create a subfolder "input" in the folder "04_postprocessing_classification_testing_approach".
- Insert the Siegfried map sheets in the input folder with the naming like {SIGFRIED_FILENAME_PREFIX}_{sheet_number}.tif
- Insert the predicted road geometries in the input folder with the naming like {sheet_number}_road_geoms.shp
- Insert the tiles with the predictions of the classification model in the input folder with the naming like {sheet_number}_{index}_class{road_cat}.tif

#### Setting
Set settings in the header of the file script_postprocessing_classification_testing_approach.py
- Set the sheet numbers of the Siegfried map sheets which should be processed
```python
SHEET_NUMBERS = ['017', '199', '385']
```
- Set the prefix of the Siegfried map sheet files e.g. 'rgb_TA_' if the file is named 'rgb_TA_017.tif'
```python
SIGFRIED_FILENAME_PREFIX = 'rgb_TA_'
```
- Set one or more buffer sizes in meters to calculate the zonal statistics
```python
BUFFERSIZES_METER = [6] # meters
```
- Set the significance levels for the Mann-Whitney U test
```python
SIGNIFICANCE_LEVELS = [0.01]
```
- Set the minimal segment length a segment has to be to be evaluated alone
```python
MINIMAL_SEGMENT_LENGTH = 50 # meters
```

#### Run script
Run file script_processing_classification_testing_approach.py
- The output will be saved in the folder "03_postprocess_classification_testing_approach/output" and will have an ESRI Shapefile per processed Siegfried sheet containing the road geometries. These files will be named like {sheet_number}_roads.shp.
- The intermediate results will be saved in the folder "03_postprocess_classification_testing_approach/temp". For each Siegfried sheet there will be a GeoTiff or ESRI Shapefile which contains:
  - The stiched maps for containing the predicted probabilities from the classification model (name: {sheet_number}_classification_class_{road_cat}.tif)


## 5. 04_evaluation
#### Data pre-processing
1. Create a subfolder within the folder "06_evlaution" and add predicted line geometries as shapefiles.
2. Modify variables within file 06_evaluation//preprocess_predictions.py:
```python
tiles = ["199_1941", "385_1941"] # tiles to evaluate
name_predictions = "_road_geoms_predicted_dp1900mm_mannwhitneyu-0-01_6m.shp" # ending of name of shapefiles
local_path_predictions = "50m_min_segment_distance\\mannwhitneyu-0-01_6m\\" # local path to location of the shapefiles
```
#### Evaluation
1. Run file evaluation.py
